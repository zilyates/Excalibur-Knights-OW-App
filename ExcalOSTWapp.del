globalvar define tempHealingDealt;
globalvar define tempHeroDamageDealt;
globalvar define tempDamageTaken;
globalvar define tempUltimatesUsed;
globalvar define tempUltimatesEarned;
globalvar define tempDeaths;
globalvar define tempWeaponAccuracy;
globalvar define tempCriticalHitAccuracy;
globalvar define tempScopedAccuracy;
globalvar define tempSoloKills;
globalvar define tempObjectiveKills;
globalvar define tempHealingReceived;
globalvar define tempDamageBlocked;
globalvar define tempEliminations;
globalvar define tempDefensiveAssists;
globalvar define tempFinalBlows;
globalvar define tempEnvirDeaths;
globalvar define tempEnvirKills;
globalvar define tempMultiKillBest;
globalvar define tempMultiKillNum;
globalvar define tempOffensiveAssists;
globalvar define index = 1;
globalvar define weaponAccHeros = 0;
globalvar define scopedAccHeros = 0;
globalvar define critAccHeros = 0;

// For symmerta weapong accuracy
// primary 
globalvar define isPlayingSym = null;    // The player who is using symmetra
playervar define timeUsingPrimary = 0;   // Count the time symmetra is using her primary fire (need to be reset after a round)
playervar define timeDamageDealt = 0;    // Count the second symmetra is dealing damage (need to be reset after a round)
globalvar define isDoingDamage = 4;

// secondary
playervar define secondaryShotCount = 0;    // Count the Shot the player shot
playervar define secondaryShotHitCount = 0; // Count the shots the player hit

// For LOS checking
playervar define deathOutLOS = 0;
globalvar define[] players;
globalvar define overallTeamTime = 0;   // count the time the entire team is in the support los
globalvar define damageRoleTime = 0;    // count the time the entire damage role is in the support los
globalvar define tankRoleTime = 0;      // count the time the entire tank role is in the support los
globalvar define roundTime = 0;         // the length of the round

// for testing 
globalvar define[] playerLOS;

// create a team array and put the support players on the first 2 slots
public define[] CreateTeamArray() {
    define[] arr;
    foreach (define player in AllPlayers(Team.Team1)) {
        arr.Append(player);
    }

    for (define i = 0; i < arr.Length; i++) {
        if (ArrayContains(AllSupportHeroes(), HeroOf(arr[i]))) {
            define currentVal = arr[i];
            define index = i;
            define pre = arr[0];

            for (define a = 1; a <= index; a++) {
                define temp = arr[i];
                arr[i] = pre;
                pre = temp;
            }
            
            arr[0] = pre;
        }
    }

    return arr;
}

// check if the entire team is in the support los (finish)
public void CheckSupportLOSAllPlayers() {
    define counter;     // count the amount of heros in the support LOS
    for (define i = 0; i < players.Length; i++) {
        if (IsInLineOfSight(EyePosition(players[0]), EyePosition(players[i]), BarrierLOS.EnemyBarriersBlock) && players[i] == players[0]) {
            counter++;
        }
        else if (IsInLineOfSight(EyePosition(players[1]), EyePosition(players[i]), BarrierLOS.EnemyBarriersBlock) && players[i] == players[1]) {
            counter++;
        }
    }

    if (counter == 6) {
        ChaseVariableAtRate(overallTeamTime, 9999, 1, RateChaseReevaluation.None);
    }
    else {
        StopChasingVariable(overallTeamTime);
    }
}

// check if the damage players are in the support los (finish)
public void CheckSupportLOSDamageRole() {
    define counter;     // count the amount of heros in the support LOS
    for (define i = 0; i < players.Length; i++) {
        if (ArrayContains(AllDamageHeroes(), HeroOf(players[i]))) {     // check if the player play dps
            if (IsInLineOfSight(EyePosition(players[0]), EyePosition(players[i]), BarrierLOS.EnemyBarriersBlock) && players[i] == players[0]) {
                counter++;
            }
            else if (IsInLineOfSight(EyePosition(players[1]), EyePosition(players[i]), BarrierLOS.EnemyBarriersBlock) && players[i] == players[1]) {
                counter++;
            }
        }
    }

    if (counter == 2) {
        ChaseVariableAtRate(damageRoleTime, 9999, 1, RateChaseReevaluation.None);
    }
    else {
        StopChasingVariable(damageRoleTime);
    }
}

// check if the tank players are in the support los (finish)
public void CheckSupportLOSTankRole() {
    define counter;     // count the amount of heros in the support LOS
    for (define i = 0; i < players.Length; i++) {
        if (ArrayContains(AllTankHeroes(), HeroOf(players[i]))) {   //check if the player play tank
            if (IsInLineOfSight(EyePosition(players[0]), EyePosition(players[i]), BarrierLOS.EnemyBarriersBlock) && players[i] == players[0]) {
                counter++;
            }
            else if (IsInLineOfSight(EyePosition(players[1]), EyePosition(players[i]), BarrierLOS.EnemyBarriersBlock) && players[i] == players[1]) {
                counter++;
            }
        }
    }

    if (counter == 2) {
        ChaseVariableAtRate(tankRoleTime, 9999, 1, RateChaseReevaluation.None);
    }
    else {
        StopChasingVariable(tankRoleTime);
    }
}


// Log the stats to the inspector efter every round
rule: "Logging to inspector player stats"
if (IsBetweenRounds()) {  
    StopChasingVariable(roundTime);
    foreach(define player in AllPlayers(Team.Team1)) {
        //Going over every hero for hero specific stats
        foreach(define hero in AllHeroes()) {
            //Get stats that specific to tank and support heroes
            if(ArrayContains(AllTankHeroes(), hero)) {
                tempDamageBlocked += PlayerHeroStat(player, hero, PlayerHeroStat.DamageBlocked);
            }
            else if(ArrayContains(AllSupportHeroes(), hero)) {
                tempHealingDealt += PlayerHeroStat(player, hero, PlayerHeroStat.HealingDealt);
            }

            //Count the amount of hero with different kind of weapon accuracy
            if(PlayerHeroStat(player, hero, PlayerHeroStat.WeaponAccuracy) > 0) {
                weaponAccHeros++;
                tempWeaponAccuracy += PlayerHeroStat(player, hero, PlayerHeroStat.WeaponAccuracy);
            }
            if(PlayerHeroStat(player, hero, PlayerHeroStat.CriticalHitAccuracy) > 0) {
                critAccHeros++;
                tempCriticalHitAccuracy += PlayerHeroStat(player, hero, PlayerHeroStat.CriticalHitAccuracy);
            }
            if(PlayerHeroStat(player, hero, PlayerHeroStat.ScopedAccuracy) > 0) {
                scopedAccHeros++;
                tempScopedAccuracy += PlayerHeroStat(player, hero, PlayerHeroStat.ScopedAccuracy);
            }

            //Hero specific stats
            tempHeroDamageDealt += PlayerHeroStat(player, hero, PlayerHeroStat.HeroDamageDealt);
            tempDamageTaken += PlayerHeroStat(player, hero, PlayerHeroStat.DamageTaken);
            tempUltimatesUsed += PlayerHeroStat(player, hero, PlayerHeroStat.UltimatesUsed);
            tempUltimatesEarned += PlayerHeroStat(player, hero, PlayerHeroStat.UltimatesEarned);
            tempDeaths += PlayerHeroStat(player, hero, PlayerHeroStat.Deaths);
            tempSoloKills += PlayerHeroStat(player, hero, PlayerHeroStat.SoloKills);
            tempObjectiveKills += PlayerHeroStat(player, hero, PlayerHeroStat.ObjectiveKills);
            tempHealingReceived += PlayerHeroStat(player, hero, PlayerHeroStat.HealingReceived);
        }

        //Player specific stats
        tempEliminations += PlayerStat(player, PlayerStat.Eliminations);
        tempDefensiveAssists += PlayerStat(player, PlayerStat.DefensiveAssists);
        tempFinalBlows += PlayerStat(player, PlayerStat.FinalBlows);
        tempEnvirDeaths += PlayerStat(player, PlayerStat.EnvironmentalDeaths);
        tempEnvirKills += PlayerStat(player, PlayerStat.EnvironmentalKills);
        tempMultiKillBest += PlayerStat(player, PlayerStat.MultikillBest);
        tempMultiKillNum += PlayerStat(player, PlayerStat.Multikills);
        tempOffensiveAssists += PlayerStat(player, PlayerStat.OffensiveAssists);

        //Calculate weapon accuracy to every hero
        tempScopedAccuracy /= scopedAccHeros;
        tempWeaponAccuracy /= weaponAccHeros;
        tempCriticalHitAccuracy /= critAccHeros;

        //Log stats that specific to tank hero or support
        if(ArrayContains(AllTankHeroes(), HeroOf(player))) {
            LogToInspector(<"<0> Damage Blocked: <1>", player, tempDamageBlocked>);
        }
        else if(ArrayContains(AllSupportHeroes(), HeroOf(player))) {
            LogToInspector(<"<0> Healing Done: <1>", player,tempHealingDealt>);
        }
        
        //Log all of the stats into the insperctor
        LogToInspector(<"<0> Damage Done: <1>", player, tempHeroDamageDealt>);
        LogToInspector(<"<0> Damage Taken: <1>", player, tempDamageTaken>);
        LogToInspector(<"<0> Ultimates Used: <1>", player, tempUltimatesUsed>);
        LogToInspector(<"<0> Ultimates Earned: <1>", player, tempUltimatesEarned>);
        LogToInspector(<"<0> Deaths: <1>", player, tempDeaths>);
        LogToInspector(<"<0> Weapon Accuracy: <1>", player, tempWeaponAccuracy>);
        LogToInspector(<"<0> Critical Hits Accuracy: <1>", player, tempCriticalHitAccuracy>);
        LogToInspector(<"<0> Scoped Weapon Accuracy: <1>", player, tempScopedAccuracy>);
        LogToInspector(<"<0> Solo Kills: <1>", player, tempSoloKills>);
        LogToInspector(<"<0> Objective Kills: <1>", player, tempObjectiveKills>);
        LogToInspector(<"<0> Healing Received: <1>", player, tempHealingReceived>);
        LogToInspector(<"<0> Eliminations: <1>", player, tempEliminations>);
        LogToInspector(<"<0> Defensive Assists: <1>", player, tempDefensiveAssists>);
        LogToInspector(<"<0> Final Blows: <1>", player, tempFinalBlows>);
        LogToInspector(<"<0> Environmental Deaths: <1>", player, tempEnvirDeaths>);
        LogToInspector(<"<0> Environmental Kills: <1>", player, tempEnvirKills>);
        LogToInspector(<"<0> Multikill Best: <1>", player, tempMultiKillBest>);
        LogToInspector(<"<0> Multikills: <1>", player, tempMultiKillNum>);
        LogToInspector(<"<0> Offensive Assists: <1>", player, tempOffensiveAssists>);
        LogToInspector(<"<0> Deaths outside of the support LOS: <1>", player, player.deathOutLOS>);
        //LogToInspector(<"<0> Time Using Primary Fire: <1>", player, timeUsingPrimary>);
        //LogToInspector(<"<0> Time Using Primary Fire: <1>", player, timeDamageDealtG>);
        //Reset all variables
        tempDamageBlocked = 0;   tempHealingDealt = 0;   tempHeroDamageDealt = 0;
        tempDamageTaken = 0;     tempUltimatesUsed = 0;  tempUltimatesEarned = 0;
        tempDeaths = 0;          tempWeaponAccuracy = 0; tempCriticalHitAccuracy = 0;
        tempScopedAccuracy = 0;  tempSoloKills = 0;      tempObjectiveKills = 0;
        tempHealingReceived = 0; tempEliminations = 0;   tempDefensiveAssists = 0;
        tempFinalBlows = 0;      tempEnvirDeaths = 0;    tempEnvirKills = 0;
        tempMultiKillBest = 0;   tempMultiKillNum = 0;   tempOffensiveAssists = 0;
    }
    // Symmetra stats
    define primaryAccuracy = isPlayingSym.timeDamageDealt / isPlayingSym.timeUsingPrimary;
    define secondaryAccuracy = isPlayingSym.secondaryShotHitCount / isPlayingSym.secondaryShotCount;
    LogToInspector(<"<0> Primary weapon accuracy in symmerta: <1>",isPlayingSym , primaryAccuracy>);
    LogToInspector(<"<0> Secondary weapon accuracy in symmerta: <1>",isPlayingSym , secondaryAccuracy>);
    // LOS stats
    define teamPercent = overallTeamTime / roundTime;
    define damageRolePercent = damageRoleTime / roundTime;
    define tankRolePercent = tankRoleTime / roundTime;
    LogToInspector(<"Support LOS of the team: <0>", teamPercent>);
    LogToInspector(<"Support LOS of the dps: <0>", damageRolePercent>);
    LogToInspector(<"Support LOS of the tank: <0>", tankRolePercent>);
    roundTime = 0;
    overallTeamTime = 0;
    damageRoleTime = 0;
    tankRoleTime = 0;
    LogToInspector("testing");
    foreach(define value in playerLOS) {
        LogToInspector(<"<0>", value>);
    }
}


// Calculate the time sym using her primary fire (Need to be tested)
rule:"Find a Symmetra player"
if (IsGameInProgress()) {
    if (HeroOf(isPlayingSym) == Hero.Symmetra) {
        players = CreateTeamArray();
        foreach (define player in AllPlayers(Team.Team1)) {
            if (HeroOf(player) == Hero.Symmetra) {
                isPlayingSym = player;
                break;
            }
        }
    }
}


// Calculate sym weapon accuracy
rule:"Is Symmetra using Primary"
Event.OngoingGlobal
if (isPlayingSym != null) {
    if (IsButtonHeld(isPlayingSym, Button.PrimaryFire)) {   // If using primary fire => start counting time
        ChaseVariableAtRate(isPlayingSym.timeUsingPrimary, 9999, 1, RateChaseReevaluation.None);
    }
    else if (Not(IsButtonHeld(isPlayingSym, Button.PrimaryFire))) { // If not using primary fire => stop counting time
        StopChasingVariable(isPlayingSym.timeUsingPrimary);
    }
}


// Calculate symmetra primary fire weapon accuracy (finish)
rule:"start timer when symmerta dealing damage"
Event.OnDamageDealt
if (EventPlayer() == isPlayingSym) {    // Make sure it will only work on our team sym player
    if (IsButtonHeld(isPlayingSym, Button.PrimaryFire)) {
        ChaseVariableAtRate(isPlayingSym.timeDamageDealt, 9999, 1, RateChaseReevaluation.None);
        isDoingDamage = 4;
        ChaseVariableAtRate(isDoingDamage, 0, 1, RateChaseReevaluation.None);
    }
    else if (Not(IsButtonHeld(isPlayingSym, Button.Melee))) {
        isPlayingSym.secondaryShotHitCount++;
    }
}


// stop Doing damage
rule:"Stop timer when symmetra stop dealing damage"
Event.OngoingGlobal
if (isDoingDamage == 0) {    // Make sure to work only when the sym player isn't shooting
    StopChasingVariable(isPlayingSym.timeDamageDealt);
}


// Calculate secondary fire weapon accuracy
rule:"count secondary fire shots"
Event.OngoingPlayer
if (EventPlayer() == isPlayingSym) {   // Make sure it will only work on our team sym player
    if(IsFiringSecondary(EventPlayer())) {
        isPlayingSym.secondaryShotCount++;
    }
}


// Out of support los
rule:"Check if a player died out side of the support line of sight "
Event.OnDeath {
    foreach(define player in AllPlayers(Team.Team1)) {
        // If Player is not event player and if the player is alive and if the player is playing a support hero => true
        if (player != EventPlayer() && IsAlive(player) && ArrayContains(AllSupportHeroes(), HeroOf(player))) {
            // If the support player can't see event player or los blocked by enemy sheild => add to out of los death counter
            if (IsInLineOfSight(EyePosition(player), EyePosition(EventPlayer()), BarrierLOS.EnemyBarriersBlock)) {
                EventPlayer().deathOutLOS++;
                break;
            }
        }
    }
}


// Check the support LOS (finish)
rule:"Check if the team is in the support los"
Event.OngoingGlobal
if (IsGameInProgress()) {
    CheckSupportLOSAllPlayers();
    CheckSupportLOSDamageRole();
    CheckSupportLOSTankRole();
    if (Not(IsBetweenRounds())) {
        ChaseVariableAtRate(roundTime, 9999, 1, RateChaseReevaluation.None);    // Stop counting the round time in the "Log stats to inspector" rule
    }
}


// Testing idea for check if the player have a good los
rule:"Check if the player have a good los"
Event.OnDeath
if (Not(IsBetweenRounds())) {
    foreach (define player in AllPlayers(Team.Team1)) {
        playerLOS = PlayersWithinRadius(EyePosition(player), 100, Team.All, RadiusLOS.SurfacesAndEnemyBarriers);
    }
}
